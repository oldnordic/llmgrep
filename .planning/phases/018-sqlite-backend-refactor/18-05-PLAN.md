---
phase: 18-sqlite-backend-refactor
plan: 05
type: execute
wave: 3
depends_on: ["18-02", "18-03", "18-04"]
files_modified:
  - src/backend/sqlite.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "SqliteBackend implements BackendTrait::search_symbols"
    - "SqliteBackend implements BackendTrait::search_references"
    - "SqliteBackend implements BackendTrait::search_calls"
    - "SqliteBackend implements BackendTrait::ast (shell out to magellan)"
    - "SqliteBackend implements BackendTrait::find_ast (shell out to magellan)"
    - "All trait methods call _impl() functions with &self.conn"
    - "All 342 existing tests pass without modification"
  artifacts:
    - path: "src/backend/sqlite.rs"
      provides: "Complete SqliteBackend BackendTrait implementation"
      exports: ["SqliteBackend", "SqliteBackend::search_symbols", "SqliteBackend::search_references", "SqliteBackend::search_calls", "SqliteBackend::ast", "SqliteBackend::find_ast"]
      covered_by: "Task 1"
  key_links:
    - from: "SqliteBackend::search_symbols"
      to: "crate::query::search_symbols_impl"
      via: "function call with &self.conn"
      pattern: "search_symbols_impl\\(&self.conn, &options\\)"
    - from: "SqliteBackend::ast"
      to: "magellan binary"
      via: "std::process::Command shell-out"
      pattern: "Command::new\\(\"magellan\"\\).args\\(\\[\"ast\""
    - from: "SqliteBackend::find_ast"
      to: "magellan binary"
      via: "std::process::Command shell-out"
      pattern: "Command::new\\(\"magellan\"\\).args\\(\\[\"find-ast\""
---

<objective>
Implement all five BackendTrait methods on SqliteBackend, calling the _impl() functions with &self.conn and shelling out to magellan for ast/find_ast.

Purpose: Complete the SqliteBackend trait implementation by wiring up all five methods to use the internal _impl() functions and magellan shell-out commands.
Output: Fully implemented SqliteBackend that passes all existing tests.
</objective>

<execution_context>
@/home/feanor/.claude/get-shit-done/workflows/execute-plan.md
@/home/feanor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/018-sqlite-backend-refactor/18-02-SUMMARY.md
@.planning/phases/018-sqlite-backend-refactor/18-03-SUMMARY.md
@.planning/phases/018-sqlite-backend-refactor/18-04-SUMMARY.md
@.planning/phases/017-backend-infrastructure/17-01-SUMMARY.md
@.planning/PROJECT.md
@.planning/ROADMAP.md
@src/query.rs
@src/backend/sqlite.rs
@src/backend/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement BackendTrait methods on SqliteBackend</name>
  <files>src/backend/sqlite.rs</files>
  <action>
    1. Add necessary imports to sqlite.rs:
       ```rust
       use crate::query::{search_symbols_impl, search_references_impl, search_calls_impl};
       use std::process::Command;
       use serde_json;
       ```

    2. Implement the five BackendTrait methods by replacing the stub implementations:

       ```rust
       impl super::BackendTrait for SqliteBackend {
           fn search_symbols(
               &self,
               options: SearchOptions,
           ) -> Result<(SearchResponse, bool, bool), LlmError> {
               search_symbols_impl(&self.conn, &options)
           }

           fn search_references(
               &self,
               options: SearchOptions,
           ) -> Result<(ReferenceSearchResponse, bool), LlmError> {
               search_references_impl(&self.conn, &options)
           }

           fn search_calls(
               &self,
               options: SearchOptions,
           ) -> Result<(CallSearchResponse, bool), LlmError> {
               search_calls_impl(&self.conn, &options)
           }

           fn ast(
               &self,
               file: &Path,
               position: Option<usize>,
               limit: usize,
           ) -> Result<serde_json::Value, LlmError> {
               let db_path = self.db_path.to_str()
                   .ok_or_else(|| LlmError::SearchFailed {
                       reason: format!("Database path {:?} is not valid UTF-8", self.db_path),
                   })?;
               let file_path = file.to_str()
                   .ok_or_else(|| LlmError::SearchFailed {
                       reason: format!("File path {:?} is not valid UTF-8", file),
                   })?;

               let mut cmd = Command::new("magellan");
               cmd.args(["ast", "--db", db_path, "--file", file_path]);

               if let Some(pos) = position {
                   cmd.args(["--position", &pos.to_string()]);
               }

               cmd.args(["--limit", &limit.to_string()]);

               let output = cmd.output()
                   .map_err(|e| LlmError::SearchFailed {
                       reason: format!("Failed to execute magellan ast command: {}", e),
                   })?;

               if !output.status.success() {
                   let stderr = String::from_utf8_lossy(&output.stderr);
                   return Err(LlmError::SearchFailed {
                       reason: format!("magellan ast command failed: {}", stderr),
                   });
               }

               serde_json::from_slice(&output.stdout)
                   .map_err(|e| LlmError::JsonError(e))
           }

           fn find_ast(&self, kind: &str) -> Result<serde_json::Value, LlmError> {
               let db_path = self.db_path.to_str()
                   .ok_or_else(|| LlmError::SearchFailed {
                       reason: format!("Database path {:?} is not valid UTF-8", self.db_path),
                   })?;

               let output = Command::new("magellan")
                   .args(["find-ast", "--db", db_path, "--kind", kind])
                   .output()
                   .map_err(|e| LlmError::SearchFailed {
                       reason: format!("Failed to execute magellan find-ast command: {}", e),
                   })?;

               if !output.status.success() {
                   let stderr = String::from_utf8_lossy(&output.stderr);
                   return Err(LlmError::SearchFailed {
                       reason: format!("magellan find-ast command failed: {}", stderr),
                   });
               }

               serde_json::from_slice(&output.stdout)
                   .map_err(|e| LlmError::JsonError(e))
           }
       }
       ```

    3. Ensure the Backend enum delegation methods in backend/mod.rs still work (they should, as they delegate to the trait methods we just implemented).

    4. Verify that all imports are correct and the module compiles.
  </action>
  <verify>cargo build 2>&1 | head -30</verify>
  <done>SqliteBackend implements all BackendTrait methods, code compiles</done>
</task>

</tasks>

<verification>
1. cargo build succeeds without errors
2. SqliteBackend implements all 5 BackendTrait methods
3. search_symbols/search_references/search_calls call _impl() functions with &self.conn
4. ast() shells out to magellan ast command with db_path
5. find_ast() shells out to magellan find-ast command with db_path
</verification>

<success_criteria>
- [ ] All 5 BackendTrait methods implemented on SqliteBackend
- [ ] Methods call _impl() functions with &self.conn
- [ ] ast() and find_ast() shell out to magellan with self.db_path
- [ ] Code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/018-sqlite-backend-refactor/18-05-SUMMARY.md`
</output>
