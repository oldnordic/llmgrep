---
phase: 18-sqlite-backend-refactor
plan: 02
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - src/query.rs
  - src/backend/sqlite.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "search_symbols_impl() function exists taking &Connection parameter"
    - "search_symbols_impl() contains verbatim SQL query logic from search_symbols()"
    - "query.rs::search_symbols() calls search_symbols_impl() as wrapper"
    - "Code compiles after _impl() function creation"
  artifacts:
    - path: "src/query.rs"
      provides: "search_symbols_impl() internal function for search_symbols logic"
      exports: ["search_symbols_impl"]
      covered_by: "Task 1"
  key_links:
    - from: "src/query.rs::search_symbols"
      to: "src/query.rs::search_symbols_impl"
      via: "function call wrapper"
      pattern: "search_symbols_impl\\(conn, options\\)"
    - from: "search_symbols_impl"
      to: "rusqlite Connection"
      via: "&Connection parameter"
      pattern: "&Connection"
---

<objective>
Create search_symbols_impl() internal function that takes &Connection parameter, containing the core search_symbols SQL query logic.

Purpose: Separate "how to query" (internal implementation with explicit Connection) from "where to get connection" (trait method with &self.conn). This enables trait method implementation while maintaining backward-compatible wrapper.
Output: search_symbols_impl() function in query.rs with verbatim search_symbols logic.
</objective>

<execution_context>
@/home/feanor/.claude/get-shit-done/workflows/execute-plan.md
@/home/feanor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/018-sqlite-backend-refactor/18-01-SUMMARY.md
@.planning/phases/017-backend-infrastructure/17-01-SUMMARY.md
@.planning/PROJECT.md
@.planning/ROADMAP.md
@src/query.rs
@src/backend/sqlite.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create search_symbols_impl() with Connection parameter</name>
  <files>src/query.rs</files>
  <action>
    1. Create new public(crate) function `search_symbols_impl()` in query.rs:
       ```rust
       pub(crate) fn search_symbols_impl(
           conn: &Connection,
           options: &SearchOptions,
       ) -> Result<(SearchResponse, bool, bool), LlmError>
       ```

    2. Copy the ENTIRE body of `search_symbols()` (lines ~345-956 in query.rs) into `search_symbols_impl()`.

    3. Make the following modifications to the copied code:
       - Remove the `Connection::open_with_flags()` call at the beginning (conn is now a parameter)
       - Remove the database validation query (conn is already valid)
       - Change `options.db_path` usage in `apply_algorithm_filters()` call to pass `options.db_path` directly
       - Keep all other logic verbatim

    4. Update the original `search_symbols()` function to be a wrapper:
       ```rust
       pub fn search_symbols(options: SearchOptions) -> Result<(SearchResponse, bool, bool), LlmError> {
           // Connection opening and validation (keep existing code from lines ~346-385)
           let conn = match Connection::open_with_flags(options.db_path, OpenFlags::SQLITE_OPEN_READ_ONLY) {
               Ok(conn) => conn,
               Err(rusqlite::Error::SqliteFailure(err, msg)) => match err.code {
                   ErrorCode::DatabaseCorrupt | ErrorCode::NotADatabase => {
                       return Err(LlmError::DatabaseCorrupted {
                           reason: msg.unwrap_or_else(|| "Database file is invalid or corrupted".to_string()),
                       });
                   }
                   ErrorCode::CannotOpen => {
                       return Err(LlmError::DatabaseNotFound {
                           path: options.db_path.display().to_string(),
                       });
                   }
                   _ => return Err(LlmError::from(rusqlite::Error::SqliteFailure(err, msg))),
               },
               Err(e) => return Err(LlmError::from(e)),
           };

           // Validation (keep existing code)
           conn.query_row(
               "SELECT name FROM sqlite_master WHERE type='table' LIMIT 1",
               [],
               |_| Ok(()),
           ).map_err(|e| match e {
               rusqlite::Error::SqliteFailure(err, ref msg) => match err.code {
                   ErrorCode::DatabaseCorrupt | ErrorCode::NotADatabase => LlmError::DatabaseCorrupted {
                       reason: msg.as_ref().map(|s| s.as_str()).unwrap_or("Database file is invalid or corrupted").to_string(),
                   },
                   _ => LlmError::from(e),
               },
               other => LlmError::from(other),
           })?;

           // Call the implementation
           search_symbols_impl(&conn, &options)
       }
       ```

    5. Verify no logic changes: The SQL queries, scoring, filtering, and post-processing must be identical.
  </action>
  <verify>cargo test --lib search_tests 2>&1 | tail -30</verify>
  <done>search_symbols_impl() exists with Connection parameter, search_symbols() is wrapper, tests pass</done>
</task>

</tasks>

<verification>
1. search_symbols_impl() function exists in query.rs with signature (conn: &Connection, options: &SearchOptions)
2. search_symbols() function calls search_symbols_impl(&conn, &options)
3. All search_symbols unit tests pass
4. SQL query logic is verbatim from original search_symbols()
</verification>

<success_criteria>
- [ ] search_symbols_impl() created with Connection parameter
- [ ] search_symbols() wrapper maintains test compatibility
- [ ] All existing search_symbols tests pass
- [ ] No logic changes (verbatim SQL copy)
</success_criteria>

<output>
After completion, create `.planning/phases/018-sqlite-backend-refactor/18-02-SUMMARY.md`
</output>
